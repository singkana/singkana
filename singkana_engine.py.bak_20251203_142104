from __future__ import annotations

from pathlib import Path
from datetime import datetime
from typing import List, Dict


# ===== ログ出力先 =====
LOG_DIR = Path("Logs")
LOG_DIR.mkdir(exist_ok=True)

CONVERT_LOG = LOG_DIR / "convert.log"
FEEDBACK_LOG = LOG_DIR / "feedback.log"


class SingKanaError(Exception):
    """シンカナ専用の業務エラー。app_web.py 側でハンドリングされる。"""
    pass


def _safe_log(path: Path, msg: str) -> None:
    """ログ周りで失敗してもサービスを落とさないためのラッパ。"""
    try:
        ts = datetime.now().isoformat(timespec="seconds")
        with path.open("a", encoding="utf-8") as f:
            f.write(f"[{ts}] {msg}\n")
    except Exception:
        # ログ失敗は握りつぶす
        pass


def init_engine() -> None:
    """
    本番ではモデルや外部APIを初期化するためのフック。
    今は「スタブ」なので何もしないが、起動ログだけ残す。
    """
    _safe_log(CONVERT_LOG, "engine initialized (stub)")


def _kana_stub(text: str) -> str:
    """
    実験版のかな生成ロジック。

    - 余計なスペースを1つに整形
    - 小文字にそろえる

    本番ではここを、ちゃんとした変換ロジックに差し替える。
    """
    normalized = " ".join(text.split())
    return normalized.lower()


def convert_lyrics(lyrics: str) -> List[Dict[str, str]]:
    """
    歌詞全体を EN / KA ペアのリストに変換するスタブ版。

    戻り値の形式：
        [
            {"en": "元の英語1行", "kana": "かな1行"},
            {"en": "元の英語2行", "kana": "かな2行"},
            ...
        ]
    """
    lines: List[Dict[str, str]] = []

    for raw in lyrics.splitlines():
        text = raw.strip()
        if not text:
            # 空行はスキップ
            continue

        kana = _kana_stub(text)

        lines.append({
            "en": text,
            "kana": kana,
        })

    _safe_log(CONVERT_LOG, f"convert ok lines={len(lines)}")
    return lines


def save_feedback(text: str) -> None:
    """
    フィードバック文章をログに残すだけのスタブ。
    """
    if not text:
        return

    _safe_log(FEEDBACK_LOG, f"feedback: {text}")
